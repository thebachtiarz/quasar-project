function utf8_decode (strData) {
  var tmpArr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0
  strData += ''
  while (i < strData.length) {
    c1 = strData.charCodeAt(i)
    if (c1 < 128) {
      tmpArr[ac++] = String.fromCharCode(c1)
      i++
    } else if ((c1 > 191) && (c1 < 224)) {
      c2 = strData.charCodeAt(i + 1)
      tmpArr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63))
      i += 2
    } else {
      c2 = strData.charCodeAt(i + 1)
      c3 = strData.charCodeAt(i + 2)
      tmpArr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))
      i += 3
    }
  }
  return tmpArr.join('')
}

export default {
  serialize (mixed_value) {
    var _utf8Size = function (str) {
      var size = 0, i = 0, l = str.length, code = ''; for (i = 0; i < l; i++) { code = str[i].charCodeAt(0); if (code < 0x0080) { size += 1; } else if (code < 0x0800) { size += 2; } else { size += 3; } }
      return size;
    }; var _getType = function (inp) {
      var type = typeof inp, match; var key; if (type === 'object' && !inp) { return 'null'; }
      if (type === "object") {
        if (!inp.constructor) { return 'object'; }
        var cons = inp.constructor.toString(); match = cons.match(/(\w+)\(/); if (match) { cons = match[1].toLowerCase(); }
        var types = ["boolean", "number", "string", "array"]; for (key in types) { if (cons == types[key]) { type = types[key]; break; } }
      }
      return type;
    }; var type = _getType(mixed_value); var val, ktype = ''; switch (type) {
      case "function": val = ""; break; case "boolean": val = "b:" + (mixed_value ? "1" : "0"); break; case "number": val = (Math.round(mixed_value) == mixed_value ? "i" : "d") + ":" + mixed_value; break; case "string": val = "s:" + _utf8Size(mixed_value) + ":\"" + mixed_value + "\""; break; case "array": case "object": val = "a"; var count = 0; var vals = ""; var okey; var key; for (key in mixed_value) {
        if (mixed_value.hasOwnProperty(key)) {
          ktype = _getType(mixed_value[key]); if (ktype === "function") { continue; }
          okey = (key.match(/^[0-9]+$/) ? parseInt(key, 10) : key); vals += this.serialize(okey) +
            this.serialize(mixed_value[key]); count++;
        }
      }
        val += ":" + count + ":{" + vals + "}"; break; case "undefined": default: val = "N"; break;
    }
    if (type !== "object" && type !== "array") { val += ";"; }
    return val;
  },
  unserialize (data) {
    var utf8Overhead = function (chr) {
      var code = chr.charCodeAt(0); if (code < 0x0080) { return 0; }
      if (code < 0x0800) { return 1; }
      return 2;
    }; var error = function (type, msg, filename, line) { throw new that.window[type](msg, filename, line); }; var read_until = function (data, offset, stopchr) {
      var buf = []; var chr = data.slice(offset, offset + 1); var i = 2; while (chr != stopchr) {
        if ((i + offset) > data.length) { error('Error', 'Invalid'); }
        buf.push(chr); chr = data.slice(offset + (i - 1), offset + i); i += 1;
      }
      return [buf.length, buf.join('')];
    }; var read_chrs = function (data, offset, length) {
      var buf; buf = []; for (var i = 0; i < length; i++) { var chr = data.slice(offset + (i - 1), offset + i); buf.push(chr); length -= utf8Overhead(chr); }
      return [buf.length, buf.join('')];
    }; var _unserialize = function (data, offset) {
      var readdata; var readData; var chrs = 0; var ccount; var stringlength; var keyandchrs; var keys; if (!offset) { offset = 0; }
      var dtype = (data.slice(offset, offset + 1)).toLowerCase(); var dataoffset = offset + 2; var typeconvert = function (x) { return x; }; switch (dtype) {
        case 'i': typeconvert = function (x) { return parseInt(x, 10); }; readData = read_until(data, dataoffset, ';'); chrs = readData[0]; readdata = readData[1]; dataoffset += chrs + 1; break; case 'b': typeconvert = function (x) { return parseInt(x, 10) !== 0; }; readData = read_until(data, dataoffset, ';'); chrs = readData[0]; readdata = readData[1]; dataoffset += chrs + 1; break; case 'd': typeconvert = function (x) { return parseFloat(x); }; readData = read_until(data, dataoffset, ';'); chrs = readData[0]; readdata = readData[1]; dataoffset += chrs + 1; break; case 'n': readdata = null; break; case 's': ccount = read_until(data, dataoffset, ':'); chrs = ccount[0]; stringlength = ccount[1]; dataoffset += chrs + 2; readData = read_chrs(data, dataoffset + 1, parseInt(stringlength, 10)); chrs = readData[0]; readdata = readData[1]; dataoffset += chrs + 2; if (chrs != parseInt(stringlength, 10) && chrs != readdata.length) { error('SyntaxError', 'String length mismatch'); }
          readdata = utf8_decode(readdata); break; case 'a': readdata = {}; keyandchrs = read_until(data, dataoffset, ':'); chrs = keyandchrs[0]; keys = keyandchrs[1]; dataoffset += chrs + 2; for (var i = 0; i < parseInt(keys, 10); i++) { var kprops = _unserialize(data, dataoffset); var kchrs = kprops[1]; var key = kprops[2]; dataoffset += kchrs; var vprops = _unserialize(data, dataoffset); var vchrs = vprops[1]; var value = vprops[2]; dataoffset += vchrs; readdata[key] = value; }
          dataoffset += 1; break; default: error('SyntaxError', 'Unknown / Unhandled data type(s): ' + dtype); break;
      }
      return [dtype, dataoffset - offset, typeconvert(readdata)];
    }; return _unserialize((data + ''), 0)[2];
  }
}
