function utf8Decode (strData) {
  var tmpArr = [], i = 0, ac = 0, c1 = 0, c2 = 0, c3 = 0
  strData += ''
  while (i < strData.length) {
    c1 = strData.charCodeAt(i)
    if (c1 < 128) {
      tmpArr[ac++] = String.fromCharCode(c1)
      i++
    } else if ((c1 > 191) && (c1 < 224)) {
      c2 = strData.charCodeAt(i + 1)
      tmpArr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63))
      i += 2
    } else {
      c2 = strData.charCodeAt(i + 1)
      c3 = strData.charCodeAt(i + 2)
      tmpArr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))
      i += 3
    }
  }
  return tmpArr.join('')
}

export default {
  serialize (needToSerialize) {
    var _utf8Size = function (str) {
      var size = 0, i = 0, l = str.length, code = ''
      for (i = 0; i < l; i++) {
        code = str[i].charCodeAt(0)
        if (code < 0x0080) size += 1
        else if (code < 0x0800) size += 2
        else size += 3
      }
      return size
    }
    var _getType = function (inp) {
      var type = typeof inp, match
      var key
      if (type === 'object' && !inp) { return 'null' }
      if (type === 'object') {
        if (!inp.constructor) { return 'object' }
        var cons = inp.constructor.toString()
        match = cons.match(/(\w+)\(/)
        if (match) { cons = match[1].toLowerCase() }
        var types = ['boolean', 'number', 'string', 'array']
        for (key in types) {
          if (cons === types[key]) {
            type = types[key]
            break
          }
        }
      }
      return type
    }
    var type = _getType(needToSerialize)
    var val, ktype = ''
    switch (type) {
      case 'function': val = ''
        break
      case 'boolean': val = 'b:' + (needToSerialize ? '1' : '0')
        break
      case 'number': val = (Math.round(needToSerialize) === needToSerialize ? 'i' : 'd') + ':' + needToSerialize
        break
      case 'string': val = 's:' + _utf8Size(needToSerialize) + ':\'' + needToSerialize + '\''
        break
      case 'array': case 'object': val = 'a'
        var count = 0
        var vals = ''
        var okey, key
        for (key in needToSerialize) {
          if (Object.prototype.hasOwnProperty.call(needToSerialize, key)) {
            ktype = _getType(needToSerialize[key])
            if (ktype === 'function') { continue }
            okey = (key.match(/^[0-9]+$/) ? parseInt(key, 10) : key)
            vals += this.serialize(okey) + this.serialize(needToSerialize[key])
            count++
          }
        }
        val += ':' + count + ':{' + vals + '}'
        break
      case 'undefined': default: val = 'N'
        break
    }
    if (type !== 'object' && type !== 'array') { val += ';' }
    return val
  },
  unserialize (data) {
    var that = this
    var utf8Overhead = function (chr) {
      var code = chr.charCodeAt(0)
      if (code < 0x0080) { return 0 }
      if (code < 0x0800) { return 1 }
      return 2
    }
    var error = function (type, msg, filename, line) { throw new that.window[type](msg, filename, line) }
    var readUntil = function (data, offset, stopchr) {
      var buf = []
      var chr = data.slice(offset, offset + 1)
      var i = 2
      while (chr !== stopchr) {
        if ((i + offset) > data.length) { error('Error', 'Invalid') }
        buf.push(chr)
        chr = data.slice(offset + (i - 1), offset + i)
        i += 1
      }
      return [buf.length, buf.join('')]
    }
    var readChrs = function (data, offset, length) {
      var buf
      buf = []
      for (var i = 0; i < length; i++) {
        var chr = data.slice(offset + (i - 1), offset + i)
        buf.push(chr)
        length -= utf8Overhead(chr)
      }
      return [buf.length, buf.join('')]
    }
    var _unserialize = function (data, offset) {
      var readdata, readData
      var chrs = 0
      var ccount, stringlength, keyandchrs, keys
      if (!offset) { offset = 0 }
      var dtype = (data.slice(offset, offset + 1)).toLowerCase()
      var dataoffset = offset + 2
      var typeconvert = function (x) { return x }
      switch (dtype) {
        case 'i': typeconvert = function (x) { return parseInt(x, 10) }
          readData = readUntil(data, dataoffset, ';')
          chrs = readData[0]
          readdata = readData[1]
          dataoffset += chrs + 1
          break
        case 'b': typeconvert = function (x) { return parseInt(x, 10) !== 0 }
          readData = readUntil(data, dataoffset, ';')
          chrs = readData[0]
          readdata = readData[1]
          dataoffset += chrs + 1
          break
        case 'd': typeconvert = function (x) { return parseFloat(x) }
          readData = readUntil(data, dataoffset, ';')
          chrs = readData[0]
          readdata = readData[1]
          dataoffset += chrs + 1
          break
        case 'n': readdata = null
          break
        case 's': ccount = readUntil(data, dataoffset, ':')
          chrs = ccount[0]
          stringlength = ccount[1]
          dataoffset += chrs + 2
          readData = readChrs(data, dataoffset + 1, parseInt(stringlength, 10))
          chrs = readData[0]
          readdata = readData[1]
          dataoffset += chrs + 2
          if (chrs !== parseInt(stringlength, 10) && chrs !== readdata.length) { error('SyntaxError', 'String length mismatch') }
          readdata = utf8Decode(readdata)
          break
        case 'a': readdata = {}
          keyandchrs = readUntil(data, dataoffset, ':')
          chrs = keyandchrs[0]
          keys = keyandchrs[1]
          dataoffset += chrs + 2
          for (var i = 0; i < parseInt(keys, 10); i++) {
            var kprops = _unserialize(data, dataoffset)
            var kchrs = kprops[1]
            var key = kprops[2]
            dataoffset += kchrs
            var vprops = _unserialize(data, dataoffset)
            var vchrs = vprops[1]
            var value = vprops[2]
            dataoffset += vchrs
            readdata[key] = value
          }
          dataoffset += 1
          break
        default: error('SyntaxError', 'Unknown / Unhandled data type(s): ' + dtype)
          break
      }
      return [dtype, dataoffset - offset, typeconvert(readdata)]
    }
    return _unserialize((data + ''), 0)[2]
  }
}
